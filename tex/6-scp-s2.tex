\subsection{表决协议}
一旦节点有了合成值它们将参与表决协议，尽管提名会继续更新合成值。一个表决$b$一个形如$b=\langle n,x\rangle$的二元组，这里$x\neq \perp$是一个值，而$b$是对讨论中的槽具体化的请示书（referendum）。$n\geq 1$是一个确保大些的表决数总是可访问的计数器。我们使用类C语言的标记$b.n$和$b.x$来表示表决$b$的计数和值的域，因而有$b=\langle b.n, b.x\rangle$。表决是全序的，而$b.n$比$b.x$更为重要{\footnote{译注：指二元组$b_1\prec b_2$当且仅当$b_1.n < b_2.n$或$b_1.n=b_2.n $且$b_1.x < b_2.x$；$b_1\equiv b_2$当且仅当$b_1.n=b_2.n\cap b_1.x=b_2.x$。}}为了方便起见，一个特殊无效的空表决$\mybm{0}=\langle 0,\perp\rangle$小于其他任何表决，而一个特别的计数器$\infty$大于其他所有的计数器。

我们分别用提交或终止一个表决$b$作为使用联邦投票来对语句$commib\;b$和$abort\;b$进行认可。对于给定的表决，$commit$和$abort$是相互冲突的，因此一个良性行为的节点最多为它们中的一个投赞成票。在第\ref{sec:voting}节的标注系统下，$commit\;b$的反是$\overline{commit\;b}$，但这里使用$abort\;b$更为直观。

由于对某个槽至多只有一个值被选用，所有提交的和被卡住的表决必须包含相同的值。粗略地说，这意味着如果陈述$commit$和更小的非终止表决相冲突的话那么它是无效的。

\begin{definition}[相容的]
        两个表决是\textbf{相容的}（记作$b_1 \sim b_2$）当且仅当$b_1.x=b_2.x$；它们是\textbf{不相容的}（记作$b_1\not\sim b_2$）当且仅当$b_1.x\neq b_2.x$。我们还将$b_1\leq b_2$（或等价地，$b_2\geq b_1$）且$b_1\sim b_2$记作$b_1\lesssim b_2$（$b_2\gtrsim b_1$）。类似地，$b_1\lnsim b_2$或$b_2\gnsim b_1$意味着$b_1\leq b_2$（或等价地$b_2\geq \b_1$）且$b_1\not\sim b_2$。
\end{definition}

\begin{definition}[就绪的]
        一个表决$b$是\textbf{就绪的}当且仅当下面集合中的每个陈述都是正确的：$\left\{abort\;b_{old}|b_{old}\lnsim b\right\}$。
\end{definition}

更准确地说，如果$b$被确认是就绪的话那$commit\;b$对投赞成票来说是有效的，节点通过在对应的终止陈述的联邦投票来保障它。全体一致地对这些陈述进行投票是方便的，因此不论我们在哪里写了``$b$就绪''周围的环境将应用于$abort$陈述的整个集合中。特别地，一个节点投票赞成、接受或确认$b$就绪当且仅当它分别投票赞成、接受或确认它们全部\textit{终止}了。

为了提交一个表决并向外界展示它的值$b.x$，SCP节点首先接受并确认$b$已经就绪，然后接受并确认$commit\;b$。在第一个完好节点投票赞成$commit\;b$之前，经由联邦投票的准备步骤确保所有完好节点最终可以确认$b$是就绪的。当一个完好节点$v$接受$commit\;b$时，意味着$b.x$最终将会被选中。然而，正如第\ref{sec:voting_safety}中所讨论的那样，为了防止$v$被污染$v$必须在作用于它之前确认$commit$。

\input{tex/6-scp-s2-1}
\input{tex/6-scp-s2-2}