\subsection{提名协议}

因为仅仅要求槽点是偏序的，一些SCP的应用讲对每个槽来说将只有一个貌似可信的表决。例如，在认证透明性中，每个中心认证机构可能有一系列它自己的槽点并且对每个槽点只签署唯一一份认证树。然而，其他一些应用承认一个槽点有多个貌似可信的值，这种情形对减少可能的输入值是有帮助的。我们的策略是从一个基于某种超时假设的可以获得共识的同步提名协议出发，并把提名协议的输出运用到一个安全性不依赖于时间的异步表决协议中~\cite{Lamport:2011:BAL:2075029.2075043}。这样一个初始的同步阶段有时候被称为调解者（conciliator，~\cite{Aspnes:2010:MAS:1835698.1835802}）。

提名协议通过对于一个槽点的候选值趋于相同得以运作。节点然后确定性地将这些候选值组合起来成一个单独的对于槽的\textit{合成}值。具体如何组合这些值取决于应用场景。举例而言，恒星网络使用SCP为每个槽点选择了一个事务集合和一个分类帐时间戳。为了组合这些候选值，恒星网络选择了这些事务集的并以及它们的时间戳的最大值。（含有无效的时间戳的值不会接受足够多的提名，从而不会变成候选者。）其他可能的方法包括，通过取集合交来组合集合，或者简单地选择那些有最大散列值的候选者。

节点通过对陈述$nominate\;x$进行联邦选举产生出一个候选值$x$。

\begin{definition}[候选的]
	一个节点$v$认为一个值$v$是\textbf{候选值}当它确认了$nominate\;x$这样一个陈述---即$v$批准了$accept(nominate\;x)$。
\end{definition}

只要节点$v$没有候选值，$v$就有可能投票赞成$nominate\;x$，这里的$x$可以是任何通过了应用层有效性检验（如时间戳不能是未来时间点）的值。事实上，一般而言$v$应当重新提名它可观察到的其他的节点提名的任何值，不过会有一些接着将要谈到的防止候选者激增的限制。一旦$v$有了候选值之后，它必须停止对任何新的$x$的值的陈述$nominate\;x$进行投票。但是如联邦选举过程规定的那样，它仍然应当接受为新的值产生的$nominate$陈述（当被{\vblock}集合接受时），并确认新的$nominate$陈述。

当一个系统有完好的节点的时候（意味着它已避免了完全的故障）提名协议有一些属性。特别地，对每个槽来说：
\begin{enumerate}
	\item\label{enum:cand_p1} 完好的节点至少可以产生一个候选值。
	\item\label{enum:cand_p2} 在某一时刻，可能的候选值集合停止增长。
	\item\label{enum:cand_p3} 如果任意一个完好的节点认为$x$是一个候选值的话，那么最终所有的完好节点都会认为$x$是一个候选值。
\end{enumerate}

现在考虑提名协议是如何达到这三个属性的。属性\ref{enum:cand_p1}可以满足是因为$nominate$陈述是不可辩驳的。节点从不会投票反对一个提名某个特别的值，且直到第一个候选值被确认为止完好节点可以提名任何值。只要有任何值通过了应用层的有效性检查，完好节点就可以投票赞成并确认$nominate\;x$。属性\ref{enum:cand_p2}可以保证，这是因为每个完好节点至少可以确认一个候选值---这会在一个有限时间内发生---不会有任何节点投票赞成新的值。因此，可能会成为候选值的只有那些已经被那些完好节点投票赞成的值。属性\ref{enum:cand_p3}是定理\ref{th10}的直接结果。

\subsubsection{具体的提名协议}