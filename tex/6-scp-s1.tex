\subsection{提名协议}

因为仅仅要求槽是偏序的，一些SCP的应用讲对每个槽来说将只有一个貌似可信的表决。例如，在认证透明性中，每个中心认证机构可能有一系列它自己的槽并且对每个槽只签署唯一一份认证树。然而，其他一些应用承认一个槽有多个貌似可信的值，这种情形对减少可能的输入值是有帮助的。我们的策略是从一个基于某种超时假设的可以获得共识的同步提名协议出发，并把提名协议的输出运用到一个安全性不依赖于时间的异步表决协议中~\cite{Lamport:2011:BAL:2075029.2075043}。这样一个初始的同步阶段有时候被称为调解者（conciliator，~\cite{Aspnes:2010:MAS:1835698.1835802}）。

提名协议通过对于一个槽的候选值趋于相同得以运作。节点然后确定性地将这些候选值组合起来成一个单独的对于槽的\textit{合成}值。具体如何组合这些值取决于应用场景。举例而言，恒星网络使用SCP为每个槽选择了一个事务集合和一个分类帐时间戳。为了组合这些候选值，恒星网络选择了这些事务集的并以及它们的时间戳的最大值。（含有无效的时间戳的值不会接受足够多的提名，从而不会变成候选者。）其他可能的方法包括，通过取集合交来组合集合，或者简单地选择那些有最大哈希值的候选者。

节点通过对陈述$nominate\;x$进行联邦选举产生出一个候选值$x$。

\begin{definition}[候选的]
	一个节点$v$认为一个值$v$是\textbf{候选值}当它确认了$nominate\;x$这样一个陈述——即$v$批准了$accept(nominate\;x)$。
\end{definition}

只要节点$v$没有候选值，$v$就有可能投票赞成$nominate\;x$，这里的$x$可以是任何通过了应用层有效性检验（如时间戳不能是未来时间点）的值。事实上，一般而言$v$应当重新提名它可观察到的其他的节点提名的任何值，不过会有一些接着将要谈到的防止候选者激增的限制。一旦$v$有了候选值之后，它必须停止对任何新的$x$的值的陈述$nominate\;x$进行投票。但是如联邦选举过程规定的那样，它仍然应当接受为新的值产生的$nominate$陈述（当被{\vblock}集合接受时），并确认新的$nominate$陈述。

当一个系统有完好的节点的时候（意味着它已避免了完全的故障）提名协议有一些属性。特别地，对每个槽来说：
\begin{enumerate}
	\item\label{enum:cand_p1} 完好的节点至少可以产生一个候选值。
	\item\label{enum:cand_p2} 在某一时刻，可能的候选值集合停止增长。
	\item\label{enum:cand_p3} 如果任意一个完好的节点认为$x$是一个候选值的话，那么最终所有的完好节点都会认为$x$是一个候选值。
\end{enumerate}

现在考虑提名协议是如何达到这三个属性的。属性\ref{enum:cand_p1}可以满足是因为$nominate$陈述是不可辩驳的。节点从不会投票反对一个提名某个特别的值，且直到第一个候选值被确认为止完好节点可以提名任何值。只要有任何值通过了应用层的有效性检查，完好节点就可以投票赞成并确认$nominate\;x$。属性\ref{enum:cand_p2}可以保证，这是因为每个完好节点至少可以确认一个候选值——这会在一个有限时间内发生——不会有任何节点投票赞成新的值。因此，可能会成为候选值的只有那些已经被那些完好节点投票赞成的值。属性\ref{enum:cand_p3}是定理\ref{th10}的直接结果。

如果有少一点的值参与组合那么提名过程将会更为高效。因此，我们给节点指派一个暂时的优先级，并且如果可能的话让每个节点提名相同值的节点为更高优先级节点。更具体地讲，设$H$是一个加密哈希函数，其值域是一个整数集合$\left\{0,\dots,h_{max}-1\right\}$。（$H$可能是$SHA-256$~\cite{shs2015}，在这种情形下$h_{max}=2^{256}$。）令$G_i(m)=H(i, x_{i-1},m)$是一个特别用于槽的哈希函数，这里的$x_{i-1}$是为$i$之前的槽选用的值（或者当槽是一个偏序时槽$i$依赖的值的有序集合）。给定一个槽$i$和一个轮计数值$n$，每个节点按照如下公式计算它的\textit{邻居}以及为它的每个邻居计算\textit{优先级}。

\begin{equation*}
	weight(v,v^{\prime}) = \frac{|\left\{q|q\in\mybm{Q}(v)\cap v^{\prime}\in q\right\}|}{|\mybm{Q}|}
\end{equation*}

\begin{equation*}
	neighbors(v,n) = \left\{v^{\prime}|G_i(N,n,v^{\prime})<h_{max}\cdot weight(v,v^{\prime})\right\}
\end{equation*}

\begin{equation*}
	priority(n,v^{\prime}) = G_i(P,n,v^{\prime})
\end{equation*}

$N$和$P$是生成两个不同哈希函数的常量。函数$weight(v,v^{\prime})$返回$\mybm{Q}$中包含$v^{\prime}$的切片的分数。通过考量$v^{\prime}$的权重作为概率的方式作用于$n$产生邻居$neighbors(v,n)$，我们也降低了不具很多信任的节点仍然可以支配某一轮的机会。

每个节点$v$最初应当找到一个节点$v_0\in neighbors(v,0)$使得它可以在它可以通信的节点间最大化$priority(0,v_0)$，然后投票赞成$nominate$和$v_0$相同的值。只有当$v=v_0$时$v$应当引入一个新的值来提名。$v$应当使用超时来决定新的用于投票赞成的$nominate$陈述。在超过时间限制$n$之后，$v$应当找到一个节点$v_n\in neighbors(v,n)$使得最大化$priority(n,v_n)$，且提名每个$v_n$所提名的。

\begin{theorem}\label{th11}
	最终所有的完好节点将有相同的合成值。
\end{theorem}

\begin{proof}
	这一定理的证明可由提名协议的三个属性而来。每个完好节点只会提名一个有限的表决。在没有恶性行为节点的情形下，完好节点将会在一个相同的候选值集合$Z$上收敛。为了阻止该收敛，恶性行为节点可能会引入新的候选值，在某个时间点上它可能是某些但不是所有的完好节点的候选者。这些候选者将需要获得从完好节点那里的选票，然而这使得它们是一个有限集合。最终恶性行为节点要么会停止扰乱系统，或者用光它们注入的新的候选值，在这种情形下完好的节点会在$Z$上收敛。
\end{proof}

\subsubsection{具体的提名协议}

\todo{图14}列出了一个节点$v$必须为每个槽维护的提名协议状态。$X$是$v$投票赞成$nominate\;x$的值$x$的集合，$Y$是$v$接受的$nominate\;x$的集合，$Z$是候选值集合——即，所有的一个包含$v$的{\quorum}已经声明$accept(nominate\;x)$的值的集合。最后，$v$维护$N$——来自每个节点的最新值。（技术上来讲，$X$，$Y$和$Z$可以从$N$的值中重新算出来，但是能够直接引用它们的值是方便的。）所有的这些域最初都被初始化为空集。注意到$X$，$Y$和$Z$都总随时间的推移而增长——节点不会从这些集合中删除元素。

\todo{图15}说明了一个包含提名协议的具体消息。由于$X$和$Y$随时间单调递增，决定在不考虑网络发送顺序的情况下来自相同节点的多个\textsl{NOMINATE}消息哪个是最新的，只要$D$不改变中间提名（否则必须记录$D$的版本信息）。只有一个远程过程调用（RPC）对提名来说是必要的——参数是发送者的最新\textsl{NOMINATE}消息而返回值是接受者的（最新\textsl{NOMINATE}消息）。如果$D$或被提名的值是数字哈希值跑，必要时第二个RPC应当允许获取没有缓存的哈希原像。

由于节点无法通过任何手段知道何时提名协议是完全的，$SCP$必须在不同的节点处处理不同的合成值。一种优化方式则可以是，节点可以尝试在它们有候选值的之前尝试预测最终的合成值。为了这样做，合成只可以在$Z\neq \emptyset$时设为$combine(Z)$，否则在$Y\neq \emptyset$时设为$combine(Z)$，否则在$X\neq \emptyset$时设为$combine(X)$。这意味着高优先级节点可以在提名的同时初始化表决，在它的第一个\textsl{NOMINATE}消息上加上第一个表决消息\textsl{PREPARE}（表述参见下文）。